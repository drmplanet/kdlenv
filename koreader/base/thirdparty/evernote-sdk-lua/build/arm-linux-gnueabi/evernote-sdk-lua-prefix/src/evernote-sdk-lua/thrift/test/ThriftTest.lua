--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'thrift.Thrift'
require 'thrift.test.ttypes'

ThriftTestClient = __TObject.new(__TClient, {
  __type = 'ThriftTestClient'
})

function ThriftTestClient:testVoid()
  self:send_testVoid()
  self:recv_testVoid()
end

function ThriftTestClient:send_testVoid()
  self.oprot:writeMessageBegin('testVoid', TMessageType.CALL, self._seqid)
  local args = testVoid_args:new{}
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testVoid()
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testVoid_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ThriftTestClient:testString(thing)
  self:send_testString(thing)
  return self:recv_testString(thing)
end

function ThriftTestClient:send_testString(thing)
  self.oprot:writeMessageBegin('testString', TMessageType.CALL, self._seqid)
  local args = testString_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testString(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testString_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testByte(thing)
  self:send_testByte(thing)
  return self:recv_testByte(thing)
end

function ThriftTestClient:send_testByte(thing)
  self.oprot:writeMessageBegin('testByte', TMessageType.CALL, self._seqid)
  local args = testByte_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testByte(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testByte_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testI32(thing)
  self:send_testI32(thing)
  return self:recv_testI32(thing)
end

function ThriftTestClient:send_testI32(thing)
  self.oprot:writeMessageBegin('testI32', TMessageType.CALL, self._seqid)
  local args = testI32_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testI32(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testI32_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testI64(thing)
  self:send_testI64(thing)
  return self:recv_testI64(thing)
end

function ThriftTestClient:send_testI64(thing)
  self.oprot:writeMessageBegin('testI64', TMessageType.CALL, self._seqid)
  local args = testI64_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testI64(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testI64_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testDouble(thing)
  self:send_testDouble(thing)
  return self:recv_testDouble(thing)
end

function ThriftTestClient:send_testDouble(thing)
  self.oprot:writeMessageBegin('testDouble', TMessageType.CALL, self._seqid)
  local args = testDouble_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testDouble(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testDouble_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testStruct(thing)
  self:send_testStruct(thing)
  return self:recv_testStruct(thing)
end

function ThriftTestClient:send_testStruct(thing)
  self.oprot:writeMessageBegin('testStruct', TMessageType.CALL, self._seqid)
  local args = testStruct_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testStruct(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testStruct_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testNest(thing)
  self:send_testNest(thing)
  return self:recv_testNest(thing)
end

function ThriftTestClient:send_testNest(thing)
  self.oprot:writeMessageBegin('testNest', TMessageType.CALL, self._seqid)
  local args = testNest_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testNest(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testNest_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testMap(thing)
  self:send_testMap(thing)
  return self:recv_testMap(thing)
end

function ThriftTestClient:send_testMap(thing)
  self.oprot:writeMessageBegin('testMap', TMessageType.CALL, self._seqid)
  local args = testMap_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testMap(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testMap_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testStringMap(thing)
  self:send_testStringMap(thing)
  return self:recv_testStringMap(thing)
end

function ThriftTestClient:send_testStringMap(thing)
  self.oprot:writeMessageBegin('testStringMap', TMessageType.CALL, self._seqid)
  local args = testStringMap_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testStringMap(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testStringMap_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testSet(thing)
  self:send_testSet(thing)
  return self:recv_testSet(thing)
end

function ThriftTestClient:send_testSet(thing)
  self.oprot:writeMessageBegin('testSet', TMessageType.CALL, self._seqid)
  local args = testSet_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testSet(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testSet_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testList(thing)
  self:send_testList(thing)
  return self:recv_testList(thing)
end

function ThriftTestClient:send_testList(thing)
  self.oprot:writeMessageBegin('testList', TMessageType.CALL, self._seqid)
  local args = testList_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testList(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testList_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testEnum(thing)
  self:send_testEnum(thing)
  return self:recv_testEnum(thing)
end

function ThriftTestClient:send_testEnum(thing)
  self.oprot:writeMessageBegin('testEnum', TMessageType.CALL, self._seqid)
  local args = testEnum_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testEnum(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testEnum_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testTypedef(thing)
  self:send_testTypedef(thing)
  return self:recv_testTypedef(thing)
end

function ThriftTestClient:send_testTypedef(thing)
  self.oprot:writeMessageBegin('testTypedef', TMessageType.CALL, self._seqid)
  local args = testTypedef_args:new{}
  args.thing = thing
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testTypedef(thing)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testTypedef_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testMapMap(hello)
  self:send_testMapMap(hello)
  return self:recv_testMapMap(hello)
end

function ThriftTestClient:send_testMapMap(hello)
  self.oprot:writeMessageBegin('testMapMap', TMessageType.CALL, self._seqid)
  local args = testMapMap_args:new{}
  args.hello = hello
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testMapMap(hello)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testMapMap_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testInsanity(argument)
  self:send_testInsanity(argument)
  return self:recv_testInsanity(argument)
end

function ThriftTestClient:send_testInsanity(argument)
  self.oprot:writeMessageBegin('testInsanity', TMessageType.CALL, self._seqid)
  local args = testInsanity_args:new{}
  args.argument = argument
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testInsanity(argument)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testInsanity_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
  self:send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
  return self:recv_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
end

function ThriftTestClient:send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
  self.oprot:writeMessageBegin('testMulti', TMessageType.CALL, self._seqid)
  local args = testMulti_args:new{}
  args.arg0 = arg0
  args.arg1 = arg1
  args.arg2 = arg2
  args.arg3 = arg3
  args.arg4 = arg4
  args.arg5 = arg5
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testMulti_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testException(arg)
  self:send_testException(arg)
  self:recv_testException(arg)
end

function ThriftTestClient:send_testException(arg)
  self.oprot:writeMessageBegin('testException', TMessageType.CALL, self._seqid)
  local args = testException_args:new{}
  args.arg = arg
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testException(arg)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testException_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
end

function ThriftTestClient:testMultiException(arg0, arg1)
  self:send_testMultiException(arg0, arg1)
  return self:recv_testMultiException(arg0, arg1)
end

function ThriftTestClient:send_testMultiException(arg0, arg1)
  self.oprot:writeMessageBegin('testMultiException', TMessageType.CALL, self._seqid)
  local args = testMultiException_args:new{}
  args.arg0 = arg0
  args.arg1 = arg1
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end

function ThriftTestClient:recv_testMultiException(arg0, arg1)
  local fname, mtype, rseqid = self.iprot:readMessageBegin()
  if mtype == TMessageType.EXCEPTION then
    local x = TApplicationException:new{}
    x:read(self.iprot)
    self.iprot:readMessageEnd()
    error(x)
  end
  local result = testMultiException_result:new{}
  result:read(self.iprot)
  self.iprot:readMessageEnd()
  if result.success then
    return result.success
  elseif result.err1 then
    error(result.err1)
  elseif result.err2 then
    error(result.err2)
  end
  error(TApplicationException:new{errorCode = TApplicationException.MISSING_RESULT})
end

function ThriftTestClient:testOneway(secondsToSleep)
  self:send_testOneway(secondsToSleep)
  end

function ThriftTestClient:send_testOneway(secondsToSleep)
  self.oprot:writeMessageBegin('testOneway', TMessageType.CALL, self._seqid)
  local args = testOneway_args:new{}
  args.secondsToSleep = secondsToSleep
  args:write(self.oprot)
  self.oprot:writeMessageEnd()
  self.oprot.trans:flush()
end
ThriftTestIface = __TObject:new{
  __type = 'ThriftTestIface'
}


ThriftTestProcessor = __TObject.new(__TProcessor
, {
 __type = 'ThriftTestProcessor'
})

function ThriftTestProcessor:process(iprot, oprot, server_ctx)
  local name, mtype, seqid = iprot:readMessageBegin()
  local func_name = 'process_' .. name
  if not self[func_name] or ttype(self[func_name]) ~= 'function' then
    iprot:skip(TType.STRUCT)
    iprot:readMessageEnd()
    x = TApplicationException:new{
      errorCode = TApplicationException.UNKNOWN_METHOD
    }
    oprot:writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
    x:write(oprot)
    oprot:writeMessageEnd()
    oprot.trans:flush()
  else
    self[func_name](self, seqid, iprot, oprot, server_ctx)
  end
end

function ThriftTestProcessor:process_testVoid(seqid, iprot, oprot, server_ctx)
  local args = testVoid_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testVoid_result:new{}
  local status, res = pcall(self.handler.testVoid, self.handler)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testVoid', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testString(seqid, iprot, oprot, server_ctx)
  local args = testString_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testString_result:new{}
  local status, res = pcall(self.handler.testString, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testString', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testByte(seqid, iprot, oprot, server_ctx)
  local args = testByte_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testByte_result:new{}
  local status, res = pcall(self.handler.testByte, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testByte', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testI32(seqid, iprot, oprot, server_ctx)
  local args = testI32_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testI32_result:new{}
  local status, res = pcall(self.handler.testI32, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testI32', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testI64(seqid, iprot, oprot, server_ctx)
  local args = testI64_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testI64_result:new{}
  local status, res = pcall(self.handler.testI64, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testI64', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testDouble(seqid, iprot, oprot, server_ctx)
  local args = testDouble_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testDouble_result:new{}
  local status, res = pcall(self.handler.testDouble, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testDouble', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testStruct(seqid, iprot, oprot, server_ctx)
  local args = testStruct_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testStruct_result:new{}
  local status, res = pcall(self.handler.testStruct, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testStruct', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testNest(seqid, iprot, oprot, server_ctx)
  local args = testNest_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testNest_result:new{}
  local status, res = pcall(self.handler.testNest, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testNest', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testMap(seqid, iprot, oprot, server_ctx)
  local args = testMap_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testMap_result:new{}
  local status, res = pcall(self.handler.testMap, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testMap', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testStringMap(seqid, iprot, oprot, server_ctx)
  local args = testStringMap_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testStringMap_result:new{}
  local status, res = pcall(self.handler.testStringMap, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testStringMap', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testSet(seqid, iprot, oprot, server_ctx)
  local args = testSet_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testSet_result:new{}
  local status, res = pcall(self.handler.testSet, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testSet', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testList(seqid, iprot, oprot, server_ctx)
  local args = testList_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testList_result:new{}
  local status, res = pcall(self.handler.testList, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testList', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testEnum(seqid, iprot, oprot, server_ctx)
  local args = testEnum_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testEnum_result:new{}
  local status, res = pcall(self.handler.testEnum, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testEnum', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testTypedef(seqid, iprot, oprot, server_ctx)
  local args = testTypedef_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testTypedef_result:new{}
  local status, res = pcall(self.handler.testTypedef, self.handler, args.thing)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testTypedef', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testMapMap(seqid, iprot, oprot, server_ctx)
  local args = testMapMap_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testMapMap_result:new{}
  local status, res = pcall(self.handler.testMapMap, self.handler, args.hello)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testMapMap', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testInsanity(seqid, iprot, oprot, server_ctx)
  local args = testInsanity_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testInsanity_result:new{}
  local status, res = pcall(self.handler.testInsanity, self.handler, args.argument)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testInsanity', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testMulti(seqid, iprot, oprot, server_ctx)
  local args = testMulti_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testMulti_result:new{}
  local status, res = pcall(self.handler.testMulti, self.handler, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testMulti', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testException(seqid, iprot, oprot, server_ctx)
  local args = testException_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testException_result:new{}
  local status, res = pcall(self.handler.testException, self.handler, args.arg)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'Xception' then
    result.err1 = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('testException', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testMultiException(seqid, iprot, oprot, server_ctx)
  local args = testMultiException_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testMultiException_result:new{}
  local status, res = pcall(self.handler.testMultiException, self.handler, args.arg0, args.arg1)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  elseif ttype(res) == 'Xception' then
    result.err1 = res
  elseif ttype(res) == 'Xception2' then
    result.err2 = res
  else
    result.success = res
  end
  oprot:writeMessageBegin('testMultiException', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

function ThriftTestProcessor:process_testOneway(seqid, iprot, oprot, server_ctx)
  local args = testOneway_args:new{}
  local reply_type = TMessageType.REPLY
  args:read(iprot)
  iprot:readMessageEnd()
  local result = testOneway_result:new{}
  local status, res = pcall(self.handler.testOneway, self.handler, args.secondsToSleep)
  if not status then
    reply_type = TMessageType.EXCEPTION
    result = TApplicationException:new{message = res}
  else
    result.success = res
  end
  oprot:writeMessageBegin('testOneway', reply_type, seqid)
  result:write(oprot)
  oprot:writeMessageEnd()
  oprot.trans:flush()
end

-- HELPER FUNCTIONS AND STRUCTURES

testVoid_args = __TObject:new{

}

function testVoid_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testVoid_args:write(oprot)
  oprot:writeStructBegin('testVoid_args')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testVoid_result = __TObject:new{

}

function testVoid_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testVoid_result:write(oprot)
  oprot:writeStructBegin('testVoid_result')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testString_args = __TObject:new{
  thing
}

function testString_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.thing = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testString_args:write(oprot)
  oprot:writeStructBegin('testString_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.STRING, 1)
    oprot:writeString(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testString_result = __TObject:new{
  success
}

function testString_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRING then
        self.success = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testString_result:write(oprot)
  oprot:writeStructBegin('testString_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.STRING, 0)
    oprot:writeString(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testByte_args = __TObject:new{
  thing
}

function testByte_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BYTE then
        self.thing = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testByte_args:write(oprot)
  oprot:writeStructBegin('testByte_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.BYTE, 1)
    oprot:writeByte(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testByte_result = __TObject:new{
  success
}

function testByte_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.BYTE then
        self.success = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testByte_result:write(oprot)
  oprot:writeStructBegin('testByte_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.BYTE, 0)
    oprot:writeByte(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testI32_args = __TObject:new{
  thing
}

function testI32_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.thing = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testI32_args:write(oprot)
  oprot:writeStructBegin('testI32_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.I32, 1)
    oprot:writeI32(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testI32_result = __TObject:new{
  success
}

function testI32_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testI32_result:write(oprot)
  oprot:writeStructBegin('testI32_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testI64_args = __TObject:new{
  thing
}

function testI64_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I64 then
        self.thing = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testI64_args:write(oprot)
  oprot:writeStructBegin('testI64_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.I64, 1)
    oprot:writeI64(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testI64_result = __TObject:new{
  success
}

function testI64_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testI64_result:write(oprot)
  oprot:writeStructBegin('testI64_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testDouble_args = __TObject:new{
  thing
}

function testDouble_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.DOUBLE then
        self.thing = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testDouble_args:write(oprot)
  oprot:writeStructBegin('testDouble_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.DOUBLE, 1)
    oprot:writeDouble(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testDouble_result = __TObject:new{
  success
}

function testDouble_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.DOUBLE then
        self.success = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testDouble_result:write(oprot)
  oprot:writeStructBegin('testDouble_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.DOUBLE, 0)
    oprot:writeDouble(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testStruct_args = __TObject:new{
  thing
}

function testStruct_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.thing = Xtruct:new{}
        self.thing:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testStruct_args:write(oprot)
  oprot:writeStructBegin('testStruct_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.STRUCT, 1)
    self.thing:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testStruct_result = __TObject:new{
  success
}

function testStruct_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Xtruct:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testStruct_result:write(oprot)
  oprot:writeStructBegin('testStruct_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testNest_args = __TObject:new{
  thing
}

function testNest_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.thing = Xtruct2:new{}
        self.thing:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testNest_args:write(oprot)
  oprot:writeStructBegin('testNest_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.STRUCT, 1)
    self.thing:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testNest_result = __TObject:new{
  success
}

function testNest_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Xtruct2:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testNest_result:write(oprot)
  oprot:writeStructBegin('testNest_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMap_args = __TObject:new{
  thing
}

function testMap_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.MAP then
        self.thing = {}
        local _ktype221, _vtype222, _size220 = iprot:readMapBegin()
        for _i=1,_size220 do
          _key224 = iprot:readI32()
          _val225 = iprot:readI32()
          self.thing[_key224] = _val225
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMap_args:write(oprot)
  oprot:writeStructBegin('testMap_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.MAP, 1)
    oprot:writeMapBegin(TType.I32, TType.I32, #self.thing)
    for kiter226,viter227 in pairs(self.thing) do
      oprot:writeI32(kiter226)
      oprot:writeI32(viter227)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMap_result = __TObject:new{
  success
}

function testMap_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype229, _vtype230, _size228 = iprot:readMapBegin()
        for _i=1,_size228 do
          _key232 = iprot:readI32()
          _val233 = iprot:readI32()
          self.success[_key232] = _val233
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMap_result:write(oprot)
  oprot:writeStructBegin('testMap_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.I32, TType.I32, #self.success)
    for kiter234,viter235 in pairs(self.success) do
      oprot:writeI32(kiter234)
      oprot:writeI32(viter235)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testStringMap_args = __TObject:new{
  thing
}

function testStringMap_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.MAP then
        self.thing = {}
        local _ktype237, _vtype238, _size236 = iprot:readMapBegin()
        for _i=1,_size236 do
          _key240 = iprot:readString()
          _val241 = iprot:readString()
          self.thing[_key240] = _val241
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testStringMap_args:write(oprot)
  oprot:writeStructBegin('testStringMap_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.MAP, 1)
    oprot:writeMapBegin(TType.STRING, TType.STRING, #self.thing)
    for kiter242,viter243 in pairs(self.thing) do
      oprot:writeString(kiter242)
      oprot:writeString(viter243)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testStringMap_result = __TObject:new{
  success
}

function testStringMap_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype245, _vtype246, _size244 = iprot:readMapBegin()
        for _i=1,_size244 do
          _key248 = iprot:readString()
          _val249 = iprot:readString()
          self.success[_key248] = _val249
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testStringMap_result:write(oprot)
  oprot:writeStructBegin('testStringMap_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.STRING, TType.STRING, #self.success)
    for kiter250,viter251 in pairs(self.success) do
      oprot:writeString(kiter250)
      oprot:writeString(viter251)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testSet_args = __TObject:new{
  thing
}

function testSet_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.SET then
        self.thing = {}
        local _etype255, _size252 = iprot:readSetBegin()
        for _i=1,_size252 do
          _elem256 = iprot:readI32()
          self.thing[_elem256] = _elem256
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testSet_args:write(oprot)
  oprot:writeStructBegin('testSet_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.SET, 1)
    oprot:writeSetBegin(TType.I32, #self.thing)
    for iter257,_ in pairs(self.thing) do
      oprot:writeI32(iter257)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testSet_result = __TObject:new{
  success
}

function testSet_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.SET then
        self.success = {}
        local _etype261, _size258 = iprot:readSetBegin()
        for _i=1,_size258 do
          _elem262 = iprot:readI32()
          self.success[_elem262] = _elem262
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testSet_result:write(oprot)
  oprot:writeStructBegin('testSet_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.SET, 0)
    oprot:writeSetBegin(TType.I32, #self.success)
    for iter263,_ in pairs(self.success) do
      oprot:writeI32(iter263)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testList_args = __TObject:new{
  thing
}

function testList_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.thing = {}
        local _etype267, _size264 = iprot:readListBegin()
        for _i=1,_size264 do
          _elem268 = iprot:readI32()
          table.insert(self.thing, _elem268)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testList_args:write(oprot)
  oprot:writeStructBegin('testList_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.LIST, 1)
    oprot:writeListBegin(TType.I32, #self.thing)
    for _,iter269 in ipairs(self.thing) do
      oprot:writeI32(iter269)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testList_result = __TObject:new{
  success
}

function testList_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.LIST then
        self.success = {}
        local _etype273, _size270 = iprot:readListBegin()
        for _i=1,_size270 do
          _elem274 = iprot:readI32()
          table.insert(self.success, _elem274)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testList_result:write(oprot)
  oprot:writeStructBegin('testList_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.LIST, 0)
    oprot:writeListBegin(TType.I32, #self.success)
    for _,iter275 in ipairs(self.success) do
      oprot:writeI32(iter275)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testEnum_args = __TObject:new{
  thing
}

function testEnum_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.thing = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testEnum_args:write(oprot)
  oprot:writeStructBegin('testEnum_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.I32, 1)
    oprot:writeI32(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testEnum_result = __TObject:new{
  success
}

function testEnum_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I32 then
        self.success = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testEnum_result:write(oprot)
  oprot:writeStructBegin('testEnum_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.I32, 0)
    oprot:writeI32(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testTypedef_args = __TObject:new{
  thing
}

function testTypedef_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I64 then
        self.thing = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testTypedef_args:write(oprot)
  oprot:writeStructBegin('testTypedef_args')
  if self.thing then
    oprot:writeFieldBegin('thing', TType.I64, 1)
    oprot:writeI64(self.thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testTypedef_result = __TObject:new{
  success
}

function testTypedef_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.I64 then
        self.success = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testTypedef_result:write(oprot)
  oprot:writeStructBegin('testTypedef_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.I64, 0)
    oprot:writeI64(self.success)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMapMap_args = __TObject:new{
  hello
}

function testMapMap_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.hello = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMapMap_args:write(oprot)
  oprot:writeStructBegin('testMapMap_args')
  if self.hello then
    oprot:writeFieldBegin('hello', TType.I32, 1)
    oprot:writeI32(self.hello)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMapMap_result = __TObject:new{
  success
}

function testMapMap_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype277, _vtype278, _size276 = iprot:readMapBegin()
        for _i=1,_size276 do
          _key280 = iprot:readI32()
          _val281 = {}
          local _ktype283, _vtype284, _size282 = iprot:readMapBegin()
          for _i=1,_size282 do
            _key286 = iprot:readI32()
            _val287 = iprot:readI32()
            _val281[_key286] = _val287
          end
          iprot:readMapEnd()
          self.success[_key280] = _val281
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMapMap_result:write(oprot)
  oprot:writeStructBegin('testMapMap_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.I32, TType.MAP, #self.success)
    for kiter288,viter289 in pairs(self.success) do
      oprot:writeI32(kiter288)
      oprot:writeMapBegin(TType.I32, TType.I32, #viter289)
      for kiter290,viter291 in pairs(viter289) do
        oprot:writeI32(kiter290)
        oprot:writeI32(viter291)
      end
      oprot:writeMapEnd()
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testInsanity_args = __TObject:new{
  argument
}

function testInsanity_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.argument = Insanity:new{}
        self.argument:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testInsanity_args:write(oprot)
  oprot:writeStructBegin('testInsanity_args')
  if self.argument then
    oprot:writeFieldBegin('argument', TType.STRUCT, 1)
    self.argument:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testInsanity_result = __TObject:new{
  success
}

function testInsanity_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.MAP then
        self.success = {}
        local _ktype293, _vtype294, _size292 = iprot:readMapBegin()
        for _i=1,_size292 do
          _key296 = iprot:readI64()
          _val297 = {}
          local _ktype299, _vtype300, _size298 = iprot:readMapBegin()
          for _i=1,_size298 do
            _key302 = iprot:readI32()
            _val303 = Insanity:new{}
            _val303:read(iprot)
            _val297[_key302] = _val303
          end
          iprot:readMapEnd()
          self.success[_key296] = _val297
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testInsanity_result:write(oprot)
  oprot:writeStructBegin('testInsanity_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.MAP, 0)
    oprot:writeMapBegin(TType.I64, TType.MAP, #self.success)
    for kiter304,viter305 in pairs(self.success) do
      oprot:writeI64(kiter304)
      oprot:writeMapBegin(TType.I32, TType.STRUCT, #viter305)
      for kiter306,viter307 in pairs(viter305) do
        oprot:writeI32(kiter306)
        viter307:write(oprot)
      end
      oprot:writeMapEnd()
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMulti_args = __TObject:new{
  arg0,
  arg1,
  arg2,
  arg3,
  arg4,
  arg5
}

function testMulti_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BYTE then
        self.arg0 = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.arg1 = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I64 then
        self.arg2 = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.MAP then
        self.arg3 = {}
        local _ktype309, _vtype310, _size308 = iprot:readMapBegin()
        for _i=1,_size308 do
          _key312 = iprot:readI16()
          _val313 = iprot:readString()
          self.arg3[_key312] = _val313
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I32 then
        self.arg4 = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.I64 then
        self.arg5 = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMulti_args:write(oprot)
  oprot:writeStructBegin('testMulti_args')
  if self.arg0 then
    oprot:writeFieldBegin('arg0', TType.BYTE, 1)
    oprot:writeByte(self.arg0)
    oprot:writeFieldEnd()
  end
  if self.arg1 then
    oprot:writeFieldBegin('arg1', TType.I32, 2)
    oprot:writeI32(self.arg1)
    oprot:writeFieldEnd()
  end
  if self.arg2 then
    oprot:writeFieldBegin('arg2', TType.I64, 3)
    oprot:writeI64(self.arg2)
    oprot:writeFieldEnd()
  end
  if self.arg3 then
    oprot:writeFieldBegin('arg3', TType.MAP, 4)
    oprot:writeMapBegin(TType.I16, TType.STRING, #self.arg3)
    for kiter314,viter315 in pairs(self.arg3) do
      oprot:writeI16(kiter314)
      oprot:writeString(viter315)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.arg4 then
    oprot:writeFieldBegin('arg4', TType.I32, 5)
    oprot:writeI32(self.arg4)
    oprot:writeFieldEnd()
  end
  if self.arg5 then
    oprot:writeFieldBegin('arg5', TType.I64, 6)
    oprot:writeI64(self.arg5)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMulti_result = __TObject:new{
  success
}

function testMulti_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Xtruct:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMulti_result:write(oprot)
  oprot:writeStructBegin('testMulti_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testException_args = __TObject:new{
  arg
}

function testException_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.arg = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testException_args:write(oprot)
  oprot:writeStructBegin('testException_args')
  if self.arg then
    oprot:writeFieldBegin('arg', TType.STRING, 1)
    oprot:writeString(self.arg)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testException_result = __TObject:new{
  err1
}

function testException_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.err1 = Xception:new{}
        self.err1:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testException_result:write(oprot)
  oprot:writeStructBegin('testException_result')
  if self.err1 then
    oprot:writeFieldBegin('err1', TType.STRUCT, 1)
    self.err1:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMultiException_args = __TObject:new{
  arg0,
  arg1
}

function testMultiException_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.arg0 = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.arg1 = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMultiException_args:write(oprot)
  oprot:writeStructBegin('testMultiException_args')
  if self.arg0 then
    oprot:writeFieldBegin('arg0', TType.STRING, 1)
    oprot:writeString(self.arg0)
    oprot:writeFieldEnd()
  end
  if self.arg1 then
    oprot:writeFieldBegin('arg1', TType.STRING, 2)
    oprot:writeString(self.arg1)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testMultiException_result = __TObject:new{
  success,
  err1,
  err2
}

function testMultiException_result:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 0 then
      if ftype == TType.STRUCT then
        self.success = Xtruct:new{}
        self.success:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.err1 = Xception:new{}
        self.err1:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.err2 = Xception2:new{}
        self.err2:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testMultiException_result:write(oprot)
  oprot:writeStructBegin('testMultiException_result')
  if self.success then
    oprot:writeFieldBegin('success', TType.STRUCT, 0)
    self.success:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.err1 then
    oprot:writeFieldBegin('err1', TType.STRUCT, 1)
    self.err1:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.err2 then
    oprot:writeFieldBegin('err2', TType.STRUCT, 2)
    self.err2:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

testOneway_args = __TObject:new{
  secondsToSleep
}

function testOneway_args:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.secondsToSleep = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function testOneway_args:write(oprot)
  oprot:writeStructBegin('testOneway_args')
  if self.secondsToSleep then
    oprot:writeFieldBegin('secondsToSleep', TType.I32, 1)
    oprot:writeI32(self.secondsToSleep)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end
