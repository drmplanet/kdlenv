--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'thrift.Thrift'
require 'thrift.test.constants'

Numberz = {
  ONE = 1,
  TWO = 2,
  THREE = 3,
  FIVE = 5,
  SIX = 6,
  EIGHT = 8
}

UserId = i64

Bonk = __TObject:new{
  message,
  type
}

function Bonk:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.message = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Bonk:write(oprot)
  oprot:writeStructBegin('Bonk')
  if self.message then
    oprot:writeFieldBegin('message', TType.STRING, 1)
    oprot:writeString(self.message)
    oprot:writeFieldEnd()
  end
  if self.type then
    oprot:writeFieldBegin('type', TType.I32, 2)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Bools = __TObject:new{
  im_true,
  im_false
}

function Bools:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BOOL then
        self.im_true = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.BOOL then
        self.im_false = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Bools:write(oprot)
  oprot:writeStructBegin('Bools')
  if self.im_true then
    oprot:writeFieldBegin('im_true', TType.BOOL, 1)
    oprot:writeBool(self.im_true)
    oprot:writeFieldEnd()
  end
  if self.im_false then
    oprot:writeFieldBegin('im_false', TType.BOOL, 2)
    oprot:writeBool(self.im_false)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Xtruct = __TObject:new{
  string_thing,
  byte_thing,
  i32_thing,
  i64_thing
}

function Xtruct:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.string_thing = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.BYTE then
        self.byte_thing = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.I32 then
        self.i32_thing = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.I64 then
        self.i64_thing = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Xtruct:write(oprot)
  oprot:writeStructBegin('Xtruct')
  if self.string_thing then
    oprot:writeFieldBegin('string_thing', TType.STRING, 1)
    oprot:writeString(self.string_thing)
    oprot:writeFieldEnd()
  end
  if self.byte_thing then
    oprot:writeFieldBegin('byte_thing', TType.BYTE, 4)
    oprot:writeByte(self.byte_thing)
    oprot:writeFieldEnd()
  end
  if self.i32_thing then
    oprot:writeFieldBegin('i32_thing', TType.I32, 9)
    oprot:writeI32(self.i32_thing)
    oprot:writeFieldEnd()
  end
  if self.i64_thing then
    oprot:writeFieldBegin('i64_thing', TType.I64, 11)
    oprot:writeI64(self.i64_thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Xtruct2 = __TObject:new{
  byte_thing,
  struct_thing,
  i32_thing
}

function Xtruct2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BYTE then
        self.byte_thing = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.struct_thing = Xtruct:new{}
        self.struct_thing:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.i32_thing = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Xtruct2:write(oprot)
  oprot:writeStructBegin('Xtruct2')
  if self.byte_thing then
    oprot:writeFieldBegin('byte_thing', TType.BYTE, 1)
    oprot:writeByte(self.byte_thing)
    oprot:writeFieldEnd()
  end
  if self.struct_thing then
    oprot:writeFieldBegin('struct_thing', TType.STRUCT, 2)
    self.struct_thing:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.i32_thing then
    oprot:writeFieldBegin('i32_thing', TType.I32, 3)
    oprot:writeI32(self.i32_thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Xtruct3 = __TObject:new{
  string_thing,
  changed,
  i32_thing,
  i64_thing
}

function Xtruct3:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.string_thing = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I32 then
        self.changed = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.I32 then
        self.i32_thing = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.I64 then
        self.i64_thing = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Xtruct3:write(oprot)
  oprot:writeStructBegin('Xtruct3')
  if self.string_thing then
    oprot:writeFieldBegin('string_thing', TType.STRING, 1)
    oprot:writeString(self.string_thing)
    oprot:writeFieldEnd()
  end
  if self.changed then
    oprot:writeFieldBegin('changed', TType.I32, 4)
    oprot:writeI32(self.changed)
    oprot:writeFieldEnd()
  end
  if self.i32_thing then
    oprot:writeFieldBegin('i32_thing', TType.I32, 9)
    oprot:writeI32(self.i32_thing)
    oprot:writeFieldEnd()
  end
  if self.i64_thing then
    oprot:writeFieldBegin('i64_thing', TType.I64, 11)
    oprot:writeI64(self.i64_thing)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Insanity = __TObject:new{
  userMap,
  xtructs
}

function Insanity:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.MAP then
        self.userMap = {}
        local _ktype1, _vtype2, _size0 = iprot:readMapBegin()
        for _i=1,_size0 do
          _key4 = iprot:readI32()
          _val5 = iprot:readI64()
          self.userMap[_key4] = _val5
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.LIST then
        self.xtructs = {}
        local _etype9, _size6 = iprot:readListBegin()
        for _i=1,_size6 do
          _elem10 = Xtruct:new{}
          _elem10:read(iprot)
          table.insert(self.xtructs, _elem10)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Insanity:write(oprot)
  oprot:writeStructBegin('Insanity')
  if self.userMap then
    oprot:writeFieldBegin('userMap', TType.MAP, 1)
    oprot:writeMapBegin(TType.I32, TType.I64, #self.userMap)
    for kiter11,viter12 in pairs(self.userMap) do
      oprot:writeI32(kiter11)
      oprot:writeI64(viter12)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.xtructs then
    oprot:writeFieldBegin('xtructs', TType.LIST, 2)
    oprot:writeListBegin(TType.STRUCT, #self.xtructs)
    for _,iter13 in ipairs(self.xtructs) do
      iter13:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

CrazyNesting = __TObject:new{
  string_field,
  set_field,
  list_field,
  binary_field
}

function CrazyNesting:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.string_field = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.SET then
        self.set_field = {}
        local _etype17, _size14 = iprot:readSetBegin()
        for _i=1,_size14 do
          _elem18 = Insanity:new{}
          _elem18:read(iprot)
          self.set_field[_elem18] = _elem18
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.list_field = {}
        local _etype22, _size19 = iprot:readListBegin()
        for _i=1,_size19 do
          _elem23 = {}
          local _ktype25, _vtype26, _size24 = iprot:readMapBegin()
          for _i=1,_size24 do
            _key28 = {}
            local _etype33, _size30 = iprot:readSetBegin()
            for _i=1,_size30 do
              _elem34 = iprot:readI32()
              _key28[_elem34] = _elem34
            end
            iprot:readSetEnd()
            _val29 = {}
            local _ktype36, _vtype37, _size35 = iprot:readMapBegin()
            for _i=1,_size35 do
              _key39 = iprot:readI32()
              _val40 = {}
              local _etype44, _size41 = iprot:readSetBegin()
              for _i=1,_size41 do
                _elem45 = {}
                local _etype49, _size46 = iprot:readListBegin()
                for _i=1,_size46 do
                  _elem50 = {}
                  local _ktype52, _vtype53, _size51 = iprot:readMapBegin()
                  for _i=1,_size51 do
                    _key55 = Insanity:new{}
                    _key55:read(iprot)
                    _val56 = iprot:readString()
                    _elem50[_key55] = _val56
                  end
                  iprot:readMapEnd()
                  table.insert(_elem45, _elem50)
                end
                iprot:readListEnd()
                _val40[_elem45] = _elem45
              end
              iprot:readSetEnd()
              _val29[_key39] = _val40
            end
            iprot:readMapEnd()
            _elem23[_key28] = _val29
          end
          iprot:readMapEnd()
          table.insert(self.list_field, _elem23)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.binary_field = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function CrazyNesting:write(oprot)
  oprot:writeStructBegin('CrazyNesting')
  if self.string_field then
    oprot:writeFieldBegin('string_field', TType.STRING, 1)
    oprot:writeString(self.string_field)
    oprot:writeFieldEnd()
  end
  if self.set_field then
    oprot:writeFieldBegin('set_field', TType.SET, 2)
    oprot:writeSetBegin(TType.STRUCT, #self.set_field)
    for iter57,_ in pairs(self.set_field) do
      iter57:write(oprot)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.list_field then
    oprot:writeFieldBegin('list_field', TType.LIST, 3)
    oprot:writeListBegin(TType.MAP, #self.list_field)
    for _,iter58 in ipairs(self.list_field) do
      oprot:writeMapBegin(TType.SET, TType.MAP, #iter58)
      for kiter59,viter60 in pairs(iter58) do
        oprot:writeSetBegin(TType.I32, #kiter59)
        for iter61,_ in pairs(kiter59) do
          oprot:writeI32(iter61)
        end
        oprot:writeSetEnd()
        oprot:writeMapBegin(TType.I32, TType.SET, #viter60)
        for kiter62,viter63 in pairs(viter60) do
          oprot:writeI32(kiter62)
          oprot:writeSetBegin(TType.LIST, #viter63)
          for iter64,_ in pairs(viter63) do
            oprot:writeListBegin(TType.MAP, #iter64)
            for _,iter65 in ipairs(iter64) do
              oprot:writeMapBegin(TType.STRUCT, TType.STRING, #iter65)
              for kiter66,viter67 in pairs(iter65) do
                kiter66:write(oprot)
                oprot:writeString(viter67)
              end
              oprot:writeMapEnd()
            end
            oprot:writeListEnd()
          end
          oprot:writeSetEnd()
        end
        oprot:writeMapEnd()
      end
      oprot:writeMapEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.binary_field then
    oprot:writeFieldBegin('binary_field', TType.STRING, 4)
    oprot:writeString(self.binary_field)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Xception = TException:new{
  __type = 'Xception',
  errorCode,
  message
}

function Xception:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.errorCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.message = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Xception:write(oprot)
  oprot:writeStructBegin('Xception')
  if self.errorCode then
    oprot:writeFieldBegin('errorCode', TType.I32, 1)
    oprot:writeI32(self.errorCode)
    oprot:writeFieldEnd()
  end
  if self.message then
    oprot:writeFieldBegin('message', TType.STRING, 2)
    oprot:writeString(self.message)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Xception2 = TException:new{
  __type = 'Xception2',
  errorCode,
  struct_thing
}

function Xception2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.errorCode = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.struct_thing = Xtruct:new{}
        self.struct_thing:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Xception2:write(oprot)
  oprot:writeStructBegin('Xception2')
  if self.errorCode then
    oprot:writeFieldBegin('errorCode', TType.I32, 1)
    oprot:writeI32(self.errorCode)
    oprot:writeFieldEnd()
  end
  if self.struct_thing then
    oprot:writeFieldBegin('struct_thing', TType.STRUCT, 2)
    self.struct_thing:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

EmptyStruct = __TObject:new{

}

function EmptyStruct:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function EmptyStruct:write(oprot)
  oprot:writeStructBegin('EmptyStruct')
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

OneField = __TObject:new{
  field
}

function OneField:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.field = EmptyStruct:new{}
        self.field:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function OneField:write(oprot)
  oprot:writeStructBegin('OneField')
  if self.field then
    oprot:writeFieldBegin('field', TType.STRUCT, 1)
    self.field:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

VersioningTestV1 = __TObject:new{
  begin_in_both,
  old_string,
  end_in_both
}

function VersioningTestV1:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.begin_in_both = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.STRING then
        self.old_string = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 12 then
      if ftype == TType.I32 then
        self.end_in_both = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function VersioningTestV1:write(oprot)
  oprot:writeStructBegin('VersioningTestV1')
  if self.begin_in_both then
    oprot:writeFieldBegin('begin_in_both', TType.I32, 1)
    oprot:writeI32(self.begin_in_both)
    oprot:writeFieldEnd()
  end
  if self.old_string then
    oprot:writeFieldBegin('old_string', TType.STRING, 3)
    oprot:writeString(self.old_string)
    oprot:writeFieldEnd()
  end
  if self.end_in_both then
    oprot:writeFieldBegin('end_in_both', TType.I32, 12)
    oprot:writeI32(self.end_in_both)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

VersioningTestV2 = __TObject:new{
  begin_in_both,
  newint,
  newbyte,
  newshort,
  newlong,
  newdouble,
  newstruct,
  newlist,
  newset,
  newmap,
  newstring,
  end_in_both
}

function VersioningTestV2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.begin_in_both = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I32 then
        self.newint = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.BYTE then
        self.newbyte = iprot:readByte()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.I16 then
        self.newshort = iprot:readI16()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.I64 then
        self.newlong = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 6 then
      if ftype == TType.DOUBLE then
        self.newdouble = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 7 then
      if ftype == TType.STRUCT then
        self.newstruct = Bonk:new{}
        self.newstruct:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 8 then
      if ftype == TType.LIST then
        self.newlist = {}
        local _etype71, _size68 = iprot:readListBegin()
        for _i=1,_size68 do
          _elem72 = iprot:readI32()
          table.insert(self.newlist, _elem72)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 9 then
      if ftype == TType.SET then
        self.newset = {}
        local _etype76, _size73 = iprot:readSetBegin()
        for _i=1,_size73 do
          _elem77 = iprot:readI32()
          self.newset[_elem77] = _elem77
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.MAP then
        self.newmap = {}
        local _ktype79, _vtype80, _size78 = iprot:readMapBegin()
        for _i=1,_size78 do
          _key82 = iprot:readI32()
          _val83 = iprot:readI32()
          self.newmap[_key82] = _val83
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 11 then
      if ftype == TType.STRING then
        self.newstring = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 12 then
      if ftype == TType.I32 then
        self.end_in_both = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function VersioningTestV2:write(oprot)
  oprot:writeStructBegin('VersioningTestV2')
  if self.begin_in_both then
    oprot:writeFieldBegin('begin_in_both', TType.I32, 1)
    oprot:writeI32(self.begin_in_both)
    oprot:writeFieldEnd()
  end
  if self.newint then
    oprot:writeFieldBegin('newint', TType.I32, 2)
    oprot:writeI32(self.newint)
    oprot:writeFieldEnd()
  end
  if self.newbyte then
    oprot:writeFieldBegin('newbyte', TType.BYTE, 3)
    oprot:writeByte(self.newbyte)
    oprot:writeFieldEnd()
  end
  if self.newshort then
    oprot:writeFieldBegin('newshort', TType.I16, 4)
    oprot:writeI16(self.newshort)
    oprot:writeFieldEnd()
  end
  if self.newlong then
    oprot:writeFieldBegin('newlong', TType.I64, 5)
    oprot:writeI64(self.newlong)
    oprot:writeFieldEnd()
  end
  if self.newdouble then
    oprot:writeFieldBegin('newdouble', TType.DOUBLE, 6)
    oprot:writeDouble(self.newdouble)
    oprot:writeFieldEnd()
  end
  if self.newstruct then
    oprot:writeFieldBegin('newstruct', TType.STRUCT, 7)
    self.newstruct:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.newlist then
    oprot:writeFieldBegin('newlist', TType.LIST, 8)
    oprot:writeListBegin(TType.I32, #self.newlist)
    for _,iter84 in ipairs(self.newlist) do
      oprot:writeI32(iter84)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.newset then
    oprot:writeFieldBegin('newset', TType.SET, 9)
    oprot:writeSetBegin(TType.I32, #self.newset)
    for iter85,_ in pairs(self.newset) do
      oprot:writeI32(iter85)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.newmap then
    oprot:writeFieldBegin('newmap', TType.MAP, 10)
    oprot:writeMapBegin(TType.I32, TType.I32, #self.newmap)
    for kiter86,viter87 in pairs(self.newmap) do
      oprot:writeI32(kiter86)
      oprot:writeI32(viter87)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.newstring then
    oprot:writeFieldBegin('newstring', TType.STRING, 11)
    oprot:writeString(self.newstring)
    oprot:writeFieldEnd()
  end
  if self.end_in_both then
    oprot:writeFieldBegin('end_in_both', TType.I32, 12)
    oprot:writeI32(self.end_in_both)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

ListTypeVersioningV1 = __TObject:new{
  myints,
  hello
}

function ListTypeVersioningV1:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.myints = {}
        local _etype91, _size88 = iprot:readListBegin()
        for _i=1,_size88 do
          _elem92 = iprot:readI32()
          table.insert(self.myints, _elem92)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.hello = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function ListTypeVersioningV1:write(oprot)
  oprot:writeStructBegin('ListTypeVersioningV1')
  if self.myints then
    oprot:writeFieldBegin('myints', TType.LIST, 1)
    oprot:writeListBegin(TType.I32, #self.myints)
    for _,iter93 in ipairs(self.myints) do
      oprot:writeI32(iter93)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.hello then
    oprot:writeFieldBegin('hello', TType.STRING, 2)
    oprot:writeString(self.hello)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

ListTypeVersioningV2 = __TObject:new{
  strings,
  hello
}

function ListTypeVersioningV2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.strings = {}
        local _etype97, _size94 = iprot:readListBegin()
        for _i=1,_size94 do
          _elem98 = iprot:readString()
          table.insert(self.strings, _elem98)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.hello = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function ListTypeVersioningV2:write(oprot)
  oprot:writeStructBegin('ListTypeVersioningV2')
  if self.strings then
    oprot:writeFieldBegin('strings', TType.LIST, 1)
    oprot:writeListBegin(TType.STRING, #self.strings)
    for _,iter99 in ipairs(self.strings) do
      oprot:writeString(iter99)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.hello then
    oprot:writeFieldBegin('hello', TType.STRING, 2)
    oprot:writeString(self.hello)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

GuessProtocolStruct = __TObject:new{
  map_field
}

function GuessProtocolStruct:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 7 then
      if ftype == TType.MAP then
        self.map_field = {}
        local _ktype101, _vtype102, _size100 = iprot:readMapBegin()
        for _i=1,_size100 do
          _key104 = iprot:readString()
          _val105 = iprot:readString()
          self.map_field[_key104] = _val105
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function GuessProtocolStruct:write(oprot)
  oprot:writeStructBegin('GuessProtocolStruct')
  if self.map_field then
    oprot:writeFieldBegin('map_field', TType.MAP, 7)
    oprot:writeMapBegin(TType.STRING, TType.STRING, #self.map_field)
    for kiter106,viter107 in pairs(self.map_field) do
      oprot:writeString(kiter106)
      oprot:writeString(viter107)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

LargeDeltas = __TObject:new{
  b1,
  b10,
  b100,
  check_true,
  b1000,
  check_false,
  vertwo2000,
  a_set2500,
  vertwo3000,
  big_numbers
}

function LargeDeltas:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.b1 = Bools:new{}
        self.b1:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 10 then
      if ftype == TType.STRUCT then
        self.b10 = Bools:new{}
        self.b10:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 100 then
      if ftype == TType.STRUCT then
        self.b100 = Bools:new{}
        self.b100:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 500 then
      if ftype == TType.BOOL then
        self.check_true = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 1000 then
      if ftype == TType.STRUCT then
        self.b1000 = Bools:new{}
        self.b1000:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 1500 then
      if ftype == TType.BOOL then
        self.check_false = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2000 then
      if ftype == TType.STRUCT then
        self.vertwo2000 = VersioningTestV2:new{}
        self.vertwo2000:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2500 then
      if ftype == TType.SET then
        self.a_set2500 = {}
        local _etype111, _size108 = iprot:readSetBegin()
        for _i=1,_size108 do
          _elem112 = iprot:readString()
          self.a_set2500[_elem112] = _elem112
        end
        iprot:readSetEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3000 then
      if ftype == TType.STRUCT then
        self.vertwo3000 = VersioningTestV2:new{}
        self.vertwo3000:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 4000 then
      if ftype == TType.LIST then
        self.big_numbers = {}
        local _etype116, _size113 = iprot:readListBegin()
        for _i=1,_size113 do
          _elem117 = iprot:readI32()
          table.insert(self.big_numbers, _elem117)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function LargeDeltas:write(oprot)
  oprot:writeStructBegin('LargeDeltas')
  if self.b1 then
    oprot:writeFieldBegin('b1', TType.STRUCT, 1)
    self.b1:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.b10 then
    oprot:writeFieldBegin('b10', TType.STRUCT, 10)
    self.b10:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.b100 then
    oprot:writeFieldBegin('b100', TType.STRUCT, 100)
    self.b100:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.check_true then
    oprot:writeFieldBegin('check_true', TType.BOOL, 500)
    oprot:writeBool(self.check_true)
    oprot:writeFieldEnd()
  end
  if self.b1000 then
    oprot:writeFieldBegin('b1000', TType.STRUCT, 1000)
    self.b1000:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.check_false then
    oprot:writeFieldBegin('check_false', TType.BOOL, 1500)
    oprot:writeBool(self.check_false)
    oprot:writeFieldEnd()
  end
  if self.vertwo2000 then
    oprot:writeFieldBegin('vertwo2000', TType.STRUCT, 2000)
    self.vertwo2000:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.a_set2500 then
    oprot:writeFieldBegin('a_set2500', TType.SET, 2500)
    oprot:writeSetBegin(TType.STRING, #self.a_set2500)
    for iter118,_ in pairs(self.a_set2500) do
      oprot:writeString(iter118)
    end
    oprot:writeSetEnd()
    oprot:writeFieldEnd()
  end
  if self.vertwo3000 then
    oprot:writeFieldBegin('vertwo3000', TType.STRUCT, 3000)
    self.vertwo3000:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.big_numbers then
    oprot:writeFieldBegin('big_numbers', TType.LIST, 4000)
    oprot:writeListBegin(TType.I32, #self.big_numbers)
    for _,iter119 in ipairs(self.big_numbers) do
      oprot:writeI32(iter119)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

NestedListsI32x2 = __TObject:new{
  integerlist
}

function NestedListsI32x2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.integerlist = {}
        local _etype123, _size120 = iprot:readListBegin()
        for _i=1,_size120 do
          _elem124 = {}
          local _etype128, _size125 = iprot:readListBegin()
          for _i=1,_size125 do
            _elem129 = iprot:readI32()
            table.insert(_elem124, _elem129)
          end
          iprot:readListEnd()
          table.insert(self.integerlist, _elem124)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function NestedListsI32x2:write(oprot)
  oprot:writeStructBegin('NestedListsI32x2')
  if self.integerlist then
    oprot:writeFieldBegin('integerlist', TType.LIST, 1)
    oprot:writeListBegin(TType.LIST, #self.integerlist)
    for _,iter130 in ipairs(self.integerlist) do
      oprot:writeListBegin(TType.I32, #iter130)
      for _,iter131 in ipairs(iter130) do
        oprot:writeI32(iter131)
      end
      oprot:writeListEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

NestedListsI32x3 = __TObject:new{
  integerlist
}

function NestedListsI32x3:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.integerlist = {}
        local _etype135, _size132 = iprot:readListBegin()
        for _i=1,_size132 do
          _elem136 = {}
          local _etype140, _size137 = iprot:readListBegin()
          for _i=1,_size137 do
            _elem141 = {}
            local _etype145, _size142 = iprot:readListBegin()
            for _i=1,_size142 do
              _elem146 = iprot:readI32()
              table.insert(_elem141, _elem146)
            end
            iprot:readListEnd()
            table.insert(_elem136, _elem141)
          end
          iprot:readListEnd()
          table.insert(self.integerlist, _elem136)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function NestedListsI32x3:write(oprot)
  oprot:writeStructBegin('NestedListsI32x3')
  if self.integerlist then
    oprot:writeFieldBegin('integerlist', TType.LIST, 1)
    oprot:writeListBegin(TType.LIST, #self.integerlist)
    for _,iter147 in ipairs(self.integerlist) do
      oprot:writeListBegin(TType.LIST, #iter147)
      for _,iter148 in ipairs(iter147) do
        oprot:writeListBegin(TType.I32, #iter148)
        for _,iter149 in ipairs(iter148) do
          oprot:writeI32(iter149)
        end
        oprot:writeListEnd()
      end
      oprot:writeListEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

NestedMixedx2 = __TObject:new{
  int_set_list,
  map_int_strset,
  map_int_strset_list
}

function NestedMixedx2:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.int_set_list = {}
        local _etype153, _size150 = iprot:readListBegin()
        for _i=1,_size150 do
          _elem154 = {}
          local _etype158, _size155 = iprot:readSetBegin()
          for _i=1,_size155 do
            _elem159 = iprot:readI32()
            _elem154[_elem159] = _elem159
          end
          iprot:readSetEnd()
          table.insert(self.int_set_list, _elem154)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.MAP then
        self.map_int_strset = {}
        local _ktype161, _vtype162, _size160 = iprot:readMapBegin()
        for _i=1,_size160 do
          _key164 = iprot:readI32()
          _val165 = {}
          local _etype169, _size166 = iprot:readSetBegin()
          for _i=1,_size166 do
            _elem170 = iprot:readString()
            _val165[_elem170] = _elem170
          end
          iprot:readSetEnd()
          self.map_int_strset[_key164] = _val165
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.LIST then
        self.map_int_strset_list = {}
        local _etype174, _size171 = iprot:readListBegin()
        for _i=1,_size171 do
          _elem175 = {}
          local _ktype177, _vtype178, _size176 = iprot:readMapBegin()
          for _i=1,_size176 do
            _key180 = iprot:readI32()
            _val181 = {}
            local _etype185, _size182 = iprot:readSetBegin()
            for _i=1,_size182 do
              _elem186 = iprot:readString()
              _val181[_elem186] = _elem186
            end
            iprot:readSetEnd()
            _elem175[_key180] = _val181
          end
          iprot:readMapEnd()
          table.insert(self.map_int_strset_list, _elem175)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function NestedMixedx2:write(oprot)
  oprot:writeStructBegin('NestedMixedx2')
  if self.int_set_list then
    oprot:writeFieldBegin('int_set_list', TType.LIST, 1)
    oprot:writeListBegin(TType.SET, #self.int_set_list)
    for _,iter187 in ipairs(self.int_set_list) do
      oprot:writeSetBegin(TType.I32, #iter187)
      for iter188,_ in pairs(iter187) do
        oprot:writeI32(iter188)
      end
      oprot:writeSetEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.map_int_strset then
    oprot:writeFieldBegin('map_int_strset', TType.MAP, 2)
    oprot:writeMapBegin(TType.I32, TType.SET, #self.map_int_strset)
    for kiter189,viter190 in pairs(self.map_int_strset) do
      oprot:writeI32(kiter189)
      oprot:writeSetBegin(TType.STRING, #viter190)
      for iter191,_ in pairs(viter190) do
        oprot:writeString(iter191)
      end
      oprot:writeSetEnd()
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  if self.map_int_strset_list then
    oprot:writeFieldBegin('map_int_strset_list', TType.LIST, 3)
    oprot:writeListBegin(TType.MAP, #self.map_int_strset_list)
    for _,iter192 in ipairs(self.map_int_strset_list) do
      oprot:writeMapBegin(TType.I32, TType.SET, #iter192)
      for kiter193,viter194 in pairs(iter192) do
        oprot:writeI32(kiter193)
        oprot:writeSetBegin(TType.STRING, #viter194)
        for iter195,_ in pairs(viter194) do
          oprot:writeString(iter195)
        end
        oprot:writeSetEnd()
      end
      oprot:writeMapEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

ListBonks = __TObject:new{
  bonk
}

function ListBonks:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.bonk = {}
        local _etype199, _size196 = iprot:readListBegin()
        for _i=1,_size196 do
          _elem200 = Bonk:new{}
          _elem200:read(iprot)
          table.insert(self.bonk, _elem200)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function ListBonks:write(oprot)
  oprot:writeStructBegin('ListBonks')
  if self.bonk then
    oprot:writeFieldBegin('bonk', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.bonk)
    for _,iter201 in ipairs(self.bonk) do
      iter201:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

NestedListsBonk = __TObject:new{
  bonk
}

function NestedListsBonk:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.bonk = {}
        local _etype205, _size202 = iprot:readListBegin()
        for _i=1,_size202 do
          _elem206 = {}
          local _etype210, _size207 = iprot:readListBegin()
          for _i=1,_size207 do
            _elem211 = {}
            local _etype215, _size212 = iprot:readListBegin()
            for _i=1,_size212 do
              _elem216 = Bonk:new{}
              _elem216:read(iprot)
              table.insert(_elem211, _elem216)
            end
            iprot:readListEnd()
            table.insert(_elem206, _elem211)
          end
          iprot:readListEnd()
          table.insert(self.bonk, _elem206)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function NestedListsBonk:write(oprot)
  oprot:writeStructBegin('NestedListsBonk')
  if self.bonk then
    oprot:writeFieldBegin('bonk', TType.LIST, 1)
    oprot:writeListBegin(TType.LIST, #self.bonk)
    for _,iter217 in ipairs(self.bonk) do
      oprot:writeListBegin(TType.LIST, #iter217)
      for _,iter218 in ipairs(iter217) do
        oprot:writeListBegin(TType.STRUCT, #iter218)
        for _,iter219 in ipairs(iter218) do
          iter219:write(oprot)
        end
        oprot:writeListEnd()
      end
      oprot:writeListEnd()
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

BoolTest = __TObject:new{
  b,
  s
}

function BoolTest:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.BOOL then
        self.b = iprot:readBool()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRING then
        self.s = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function BoolTest:write(oprot)
  oprot:writeStructBegin('BoolTest')
  if self.b then
    oprot:writeFieldBegin('b', TType.BOOL, 1)
    oprot:writeBool(self.b)
    oprot:writeFieldEnd()
  end
  if self.s then
    oprot:writeFieldBegin('s', TType.STRING, 2)
    oprot:writeString(self.s)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

StructA = __TObject:new{
  s
}

function StructA:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRING then
        self.s = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function StructA:write(oprot)
  oprot:writeStructBegin('StructA')
  if self.s then
    oprot:writeFieldBegin('s', TType.STRING, 1)
    oprot:writeString(self.s)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

StructB = __TObject:new{
  aa,
  ab
}

function StructB:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.STRUCT then
        self.aa = StructA:new{}
        self.aa:read(iprot)
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.STRUCT then
        self.ab = StructA:new{}
        self.ab:read(iprot)
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function StructB:write(oprot)
  oprot:writeStructBegin('StructB')
  if self.aa then
    oprot:writeFieldBegin('aa', TType.STRUCT, 1)
    self.aa:write(oprot)
    oprot:writeFieldEnd()
  end
  if self.ab then
    oprot:writeFieldBegin('ab', TType.STRUCT, 2)
    self.ab:write(oprot)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end
